# embedded_trace

Tracing for embedded systems with text and graphical reporting capabilities.


## Introduction


This SW implements a tracing/logging facility intended for bare metal 
embedded systems to analyze events and timing/performance among them.

It assumes only that a buffer of memory is available to log events 
and that this buffer can be dumped out of the embedded system when 
the user triggers this dump (for example through a serial port).

The messages to be logged are defined by the user in a file (`msgs.txt`)
this file when processed will generate a set of macros in a `.h` file
(`msgs_auto.h`). These macros are to be inserted by the user in its 
code in the appropriate places to log intended events / calls etc.

The dumped trace has ASCII hex format and not directly readable. It
is inteded to be post-processed on a host machine.

The trace can be post-processed mainly into 2 formats:

  * **report** (`.rpt`) : ASCII one line per event, includes timing information
  event name and arguments.

  * **value change dump** (`.vcd`) : a common format used in FPGA/ASIC flows 
  to analyze timing and functionality of digital designs. This format
  can be visualized using standard waveform dump viewers, e.g.
  the open source [gtkwave](https://gtkwave.sourceforge.net/) waveform viewer.

# Directory structure

```
├── Makefile            - Drives pre-processing and post-processing steps. 
├── README.md           - This file.
├── emblog              - Main source code of this library
├── example             - An example of use
│   ├── main.c              - Code that inserts tracing calls
│   ├── msgs.txt            - User defined messages. An example
│   └── msgs_auto.h         - Generated from msgs.txt when running 'make run', make rpt' or 'make vcd'
├── rundir              - Area where 'example' application is run and temporary files generated
└── scripts             
    ├── gen_log.py      - Used to convert msgs.txt into msgs_auto.h as well as to post-process 
    │                     the ASCII hex dump generated by the user's code from the trace circular buffer
    │                     into a .rpt file and a .trace file (internal to help in the generation of .vcd file) 
    └── trace2vcd.pl    - Utility to covert the trace into a .vcd file
```

# Example of use:


1) To build the example application:

    $ make build

This step will build the application `bin/example/main.c` with the relevant files of this library. Note that this step also
processes `msgs.txt` into `msgs_auto.h`

2) Application run

    $ make run

Runs the application built above in the directory 'rundir' dumping stdout of this application into
`rundir/example_out.log`. Amonght other things this file will contain a trace buffer dump for later
post-processing. This is an example of such a trace buffer dump (note that the 1st 5 lines are
informative and not parsed by the scripts).

```
cursor=20
wrapped=1
enabled=1
evnt_cnt=900
max_entries=256
=== Start buffer dump. Most recent first ===
00002D03 00002E04 0000006E 00002F05 000000DC 00004D45 000000DD 00004D44
0000006F 2C1CD701 00003D41 00003900 00004102 00003F03 00004104 0000006E
00005105 000000DC 00006745 000000DD 0000CB44 0000006F 2C617501 00002541
00002000 00002702 00002903 00002804 0000006E 00005105 000000DC 00004545
000000DD 00003944 0000006F 2C1E6301 00002341 00002A00 00004902 00002703
00002A04 0000006E 00002B05 000000DC 00004945 000000DD 00004B44 0000006F
2C18DC01 00002441 00002300 00002402 00005C03 00002A04 0000006E 00002D05
000000DC 00004545 000000DD 0000B944 0000006F 2C1C8101 00002D41 00002700
00003002 00003103 00002F04 0000006E 00003105 000000DC 00006545 000000DD
00005944 0000006F 2DCD4501 00002D41 00003500 00002D02 00002E03 00002B04
0000006E 00006705 000000DC 00004E45 000000DD 0000FD44 0000006F 2DD27D01
00002941 00004500 00004502 00003303 00003004 0000006E 00004A05 000000DC
00003A45 000000DD 00006244 0000006F 2D54AA01 00002941 00002600 00004F02
00005003 00004904 0000006E 00005705 000000DC 00004D45 000000DD 0000E044
0000006F 38138901 00006341 00006100 0000FE02 00004F03 00004A04 0000006E
00006F05 000000DC 0000CF45 000000DD 0001E144 0000006F 3E88BC01 00005E41
0000DD00 00008802 00006703 00006204 0000006E 00008805 000000DC 00008C45
000000DD 00027C44 0000006F 3BFCC601 00006641 00006900 00008402 00008203
00008404 0000006E 00009805 000000DC 00009145 000000DD 00014D44 0000006F
3DA2D901 00003D41 00004D00 00004502 00007403 00007E04 0000006E 00007F05
000000DC 00008845 000000DD 00013944 0000006F 360FE301 00005141 00006800
00006F02 00005603 00007504 0000006E 00008805 000000DC 00006245 000000DD
00032E44 0000006F 38E5F701 00005341 00006800 00008602 00006303 00008404
0000006E 0000A105 000000DC 00005745 000000DD 00017344 0000006F 345FF901
00003B41 00003B00 00003D02 00003F03 00005304 0000006E 00005305 000000DC
00004B45 000000DD 0000C144 0000006F 2C451501 00002641 00004900 00002502
00002C03 00002B04 0000006E 00003105 000000DC 00005145 000000DD 00005944
0000006F 2C1BA501 00003C41 00004700 00003B02 00003D03 00004D04 0000006E
00006005 000000DC 00005345 000000DD 00013D44 0000006F 331EF401 00007541
00008600 00008002 00005C03 00007104 0000006E 00008405 000000DC 0000AD45
000000DD 00013944 0000006F 32BD0901 00002741 00002D00 00002802 00003503
00004B04 0000006E 00003305 000000DC 00003745 000000DD 00007544 0000006F
=== End buffer dump ===

```

This step also attempts `make build` so step 1) is not required in practice

3a) Generation of a readable report

    $ make rpt

This step will process ASCII hex file `rundir/example_out.log` into a human readable report with timing and
event information.

this step also attemps 2) and prior steps

3b) Generation of a `.vcd` file (graphical report)

    $ make vcd

This step will process ASCII hex file `rundir/example_out.log` into a `.vcd` file that can be loaded into a
waveform viewer.

# Message Definition

The message format file `msgs.txt` defines what messages we want logged. This is an example of it:

```
# misc
level:1 some_event:event
level:1 long_comp_body:flag

# stop/clear feature events
level:1 iter_start:event
level:1 iter_stop:event

level:0 msg1:flag a:u32
level:1 msg2:flag b:u32
level:2 msg3:flag c:u32
```

The syntax is defined in the following EBNF:

```ebnf
  <msgs> ::= ( <msg> '\n' )+

  <msg> ::= [level:<int>] <msg_name>:<msg_type>  (<arg_name>:<arg_type>)*

  <msg_name> ::= <ID>
  <msg_type> ::= 'event' | 'flag'

  <arg_name> ::= <ID>
  <arg_type> ::= 'u32'     # arg_type is currently only u32, to be expanded in the future

  <ID> ::= [A-Za-z0-9_]+
```

Semantics:

  * `level`: is optional, by default 1. 
   
     `./gen_log.py --dbg_level n` will force messages with level <= n to be 
     issued (rest ignored). By default min_dbg_level is 1 so log messages 
     of level 0/1 are logged and messages with level 2 or higher are ignored. 
     The level is passed at code instrumentation time (`gen_log.py` generates 
     macros with the level for the message and the level desired) so there is
     no run-time overhead in messages not logged.

  * `msg_type`: can be either `event` or `flag`
    * `event`: type of messages have no duration. Happen at a specific point of time
    * `flag`:  type of events can be 0 or 1. They can be used to measure time
               durations (set to 1 at the beginning, set to 0 at the end for
               instance). The duration can be visualized graphicaly

Messages of either type can optionally have extra arguments (currently only `u32`
type supported). Any optional number of them with the format `name:type` can be
included.


# Macro generation and usage

With the messages defined with the format above, the following call generates a set
of macros that when called in the code will generate approapriate messages in the
trace buffer:

    $ ./scripts/gen_log.py -msgs msgs.txt -hdrs msgs_auto.h
    
For example the following message:

    level:2 msg3:flag c:u32
    
Will generate the following macro:

    #define EMB_LOG_MSG3(flag_val, c) ...
    
That can be called in user code where appropriate. See [example/main.c](example/main.c) for an example.

# Command line syntax:

```
usage: gen_log.py [-h] [--hex_log HEX_LOG] [--hdrs HDRS] [--msgs MSGS] [--output_style {rpt,vcd}] [--out_rpt OUT_RPT]
                  [--freq_in_mhz FREQ_IN_MHZ] [--dbg_level DBG_LEVEL] [-v | -q]

options:
  -h, --help            show this help message and exit
  --hex_log HEX_LOG     dump file to generate the log from (default: None)
  --hdrs HDRS           header file to generate for c inclusion (default: None)
  --msgs MSGS           msg definition file (default: msgs.txt)
  --output_style {rpt,vcd}
                        rpt: readable trace, vcd: VCD waves (default: vcd)
  --out_rpt OUT_RPT     output file name for reports (default: /dev/stdout)
  --freq_in_mhz FREQ_IN_MHZ
                        Frequency of timestamp ticks in MHz (default: 1000.0)
  --dbg_level DBG_LEVEL
                        messages with level equal or above this will be dumpled (default: 1)
  -v, --verbose         verbose (default: False)
  -q, --quiet           quiet (default: False)
  ```
  
  The script is typically invoked twice
  
  1) To generate macro file to instrument the code. E.g

    $ ./scripts/gen_log.py -msgs msgs.txt -hdrs msgs_auto.h
    
  2) To postprocess a trace buffer dump into either `rpt` or `vcd` format after application execution and buffer dump. E.g 

    $ scripts/gen_log.py -msgs msgs.txt -freq_in_mhz 100.0 -output_style=rpt -hex_log example.log > example.rpt
    
  This is an example of such a report (`rpt` format)
  
  ```
   n :        cycle         uSecs  delta-uSecs  event_name args
===============================================================
   0 :           77         0.048        0.048  msg1(1) a=0x6f
   1 :          122         0.076        0.028  msg2(1) b=0xdd
   2 :          161         0.101        0.024  msg2(0) b=0xdc
   3 :          199         0.124        0.024  msg1(0) a=0x6e
   4 :          260         0.163        0.038  iter_stop
   5 :          299         0.187        0.024  iter_start
   6 :          331         0.207        0.020  some_event
   7 :          362         0.226        0.019  long_comp_body(1)
   8 :      2410965      1506.853     1506.627  long_comp_body(0)
   9 :      2411032      1506.895        0.042  msg1(1) a=0x6f
  10 :      2411074      1506.921        0.026  msg2(1) b=0xdd
  11 :      2411115      1506.947        0.026  msg2(0) b=0xdc
  12 :      2411152      1506.970        0.023  msg1(0) a=0x6e
  13 :      2411215      1507.009        0.039  iter_stop
  14 :      2411251      1507.032        0.022  iter_start
  15 :      2411282      1507.051        0.019  some_event
  16 :      2411316      1507.072        0.021  long_comp_body(1)
  17 :      4820090      3012.556     1505.484  long_comp_body(0)
  18 :      4820126      3012.579        0.022  msg1(1) a=0x6f
  19 :      4820165      3012.603        0.024  msg2(1) b=0xdd
  20 :      4820204      3012.628        0.024  msg2(0) b=0xdc
  ...
  
  ```

Note that a clock frequency is provided to convert from CPU ticks (what gets store in the trace buffer) to wall time.


If you wanted to see this graphically, generate a `vcd` file:

    $ scripts/gen_log.py -msgs msgs.txt -freq_in_mhz 100.0 -output_style=vcd -hex_log example.log > example.vcd
    
Assuming you have `gtkwave` installed in your system, you can open the file as (assuming MacOs)

    $ open example.vcd
    
After adding relevant signals to the display and zooming in should look like the following:

   ![](doc/gtkwave_example.png?raw=true)
    
Note that time is not absolute wall time. Time 0 corresponds to the oldest sample found in the circular buffer.
As it is a circular buffer this time will depend on when we decide to stop and dump the trace buffer. This 
behavior can be altered as indicated in the next section.

# Options to control circular buffer dumping

A typical embedded aplication will have at least the following calls to enable this circular buffer dumping

```C
  #include "emb_log.h"     // include library header file
  #include "msgs_auto.h"   // include auto-generated macrors (from msgs.txt)


        emb_log_init();          // initialize emb_log internal data structures
        emb_log_set_enable(1);   // this call will enable dumping whenever EMB_LOG_...
                                 // macro calls are executed. Before this they will
                                 // be ignored
      
        ...
            EMB_LOG_ITER_STOP(); // example of macro call that dumps something into the trace buffer
        ...
        
        emb_log_dump(0);  // 0 is a format id, so far the only one supported


```

The following section of `emb_log.h` defines other relevant API calls

```C
#ifndef EMB_LOG_ENTRIES
 // each entry is 4 B. Different messages may use different number of entries
 // depending on arguments and size of relative time-stamp (1 being minimum)
 #define EMB_LOG_ENTRIES 256   // 1KB
#endif

// Required call before usage to initialize internal data structures
void emb_log_init();

// Enable/disable log based on argument
void emb_log_set_enable(int on);

// Enable the log after 'cnt' messages have been attempted to log
void emb_log_start_after_cnt_msgs(int cnt);

// Disable log after log has been enabled and 'cnt' messages
// have been logged
void emb_log_stop_after_cnt_capt_msgs(int cnt);

// if val is != 0, log doesn't wrap around
void emb_log_set_one_shot(int val);

// Dump current log
void emb_log_dump(int format);
```

# Customization

The timer tick may need to be customized for your system. The default assumes we are running on a x86 and rdtsc timer 
is used by default to make it easy to explore the functionality of the library in your host system. There is also a 
sample implementation for Cadence/Tensilica XTENSA processors. For example in `emb_log.c` the function `get_time_stamp()` 
needs
to be customuzed to your system in this file. The frequency of this clock provided with `--freq_in_mhz MHZ` option in
`gen_log.py` reporting calls

```C

  #if defined(EMB_LOG_XTENSA)
      // Tensilica implementation assumed here (tested a number of years ago, may need updates)
      #include "xtensa_api.h"
      #include <xtensa/config/core.h>
      #include <xtensa/xtruntime.h>
      #include <xtensa/hal.h>
      uint32_t get_time_stamp() { return xthal_get_ccount(); }
      // can be mapped to .text if desired as access is always in multiples of 32-bits
      static int32_t emb_log_buf[EMB_LOG_ENTRIES] __attribute__((section(".text")));
  #else
      #include <sys/time.h>
      // default is an x86 implementation
      #include "rdtsc.h"
      uint32_t get_time_stamp() {
          return rdtsc();
      }
      static int32_t emb_log_buf[EMB_LOG_ENTRIES];
  #endif
  
  ```

The following macros need to be customized on your system as well (to allow atomic operations on the code within them
that updates the log. This is necessary only if you are logging from multiple threads. If you intend to log from main
thread and ISR's then the macros should disable/enable interrupts respectively

Customize in `debug_hw_specific.h`

    #define EMB_LOG_ENTER_CRITICAL_SECT  ...
    #define EMB_LOG_EXIT_CRITICAL_SECT   ...

`debug_hw_specific.c` defines a set of calls oriented do dumping the trace buffer on a serial port that need to 
be customize to connect to your serial port. Defaults just dump to `stdout`

# Compile time controls

The following constants can be defined at compilation time to change the behavior of the library

  * EMB_LOG_ENTRIES:  The value passed (256 if not provided) defines the buffer log size in 32-bit words
  * EMB_LOG_XTENSA:   If defined the code that defines timer tick will be customized for extensa processors

